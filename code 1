<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bridge Load Simulator</title>
  <style>
    body { font-family: sans-serif; margin: 16px; background: #f5f7fb; color: #0f172a; }
    #app { display: grid; grid-template-columns: 360px 1fr; gap: 16px; align-items: start; }
    .card { background: #fff; padding: 12px 14px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); }
    label { display: block; margin: 8px 0 4px; font-weight: 600; }
    input, select, button { width: 100%; padding: 8px; margin-bottom: 8px; border-radius: 6px; border: 1px solid #d4d8e1; }
    button { cursor: pointer; border: none; background: #2563eb; color: #fff; font-weight: 600; }
    button.secondary { background: #f1f5f9; color: #0f172a; border: 1px solid #d4d8e1; }
    #status { padding: 10px; border-radius: 8px; font-weight: 700; margin: 10px 0; }
    .ok { background: #e6f7ed; color: #1f7a3d; }
    .fail { background: #ffecec; color: #c02828; }
    canvas { width: 100%; height: 420px; background: #eef2f7; border-radius: 10px; cursor: grab; }
    canvas.dragging { cursor: grabbing; }
    ul { padding-left: 18px; }
    li { margin: 4px 0; font-size: 14px; }
    small { color: #475569; }
    .inline { display: flex; gap: 8px; }
    .inline > div { flex: 1; }
  </style>
</head>
<body>
<h2>Bridge Load Simulator</h2>
<div id="app">
  <div class="card">
    <label>Bridge type</label>
    <select id="bridgeType">
      <option value="steel">Steel I-beam (stiff, high capacity)</option>
      <option value="concrete">Prestressed concrete girder</option>
      <option value="wood">Glulam timber</option>
      <option value="custom">Custom</option>
    </select>

    <div class="inline">
      <div>
        <label>Span (m)</label>
        <input type="number" id="span" value="20" min="5" max="150" step="1">
      </div>
      <div>
        <label>Capacity (kN)</label>
        <input type="number" id="capacity" value="1200" min="100" max="5000" step="50">
      </div>
    </div>

    <div class="inline">
      <div>
        <label>Moment capacity (kN·m)</label>
        <input type="number" id="momentCapacity" value="2500" min="100" max="10000" step="50">
      </div>
      <div>
        <label>Damping (visual only)</label>
        <input type="number" id="damping" value="0.5" min="0" max="1" step="0.1">
      </div>
    </div>

    <label>Add load</label>
    <select id="loadType">
      <option value="car">Car (15 kN)</option>
      <option value="truck">Truck (80 kN)</option>
      <option value="bus">Bus (60 kN)</option>
      <option value="custom">Custom</option>
    </select>
    <div class="inline">
      <div>
        <label>Custom weight (kN)</label>
        <input type="number" id="customWeight" value="50" min="1" max="500" step="5" disabled>
      </div>
      <div>
        <label>Position (0–100%)</label>
        <input type="number" id="position" value="50" min="0" max="100" step="5">
      </div>
    </div>
    <button id="addBtn">Add load</button>
    <button class="secondary" id="resetBtn">Reset loads</button>

    <div id="status" class="ok">Bridge OK</div>
    <p><strong>Total load:</strong> <span id="totalLoad">0</span> kN</p>
    <p><strong>Capacity:</strong> <span id="capText">1200</span> kN</p>
    <p><strong>Max bending moment:</strong> <span id="momentText">0</span> / <span id="momentCapText">2500</span> kN·m</p>
    <p><strong>Support reactions:</strong> L <span id="leftReaction">0</span> kN, R <span id="rightReaction">0</span> kN</p>

    <h4>Loads (drag on canvas to move):</h4>
    <ul id="loadList"></ul>
  </div>

  <div class="card">
    <canvas id="canvas" width="1000" height="420"></canvas>
    <small>Blue bars = loads (drag to move). Red = shear diagram. Purple = bending moment diagram.</small>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const bridgeType = document.getElementById('bridgeType');
  const spanInput = document.getElementById('span');
  const capacityInput = document.getElementById('capacity');
  const momentCapacityInput = document.getElementById('momentCapacity');
  const dampingInput = document.getElementById('damping');
  const loadType = document.getElementById('loadType');
  const customWeight = document.getElementById('customWeight');
  const positionInput = document.getElementById('position');
  const addBtn = document.getElementById('addBtn');
  const resetBtn = document.getElementById('resetBtn');
  const loadList = document.getElementById('loadList');
  const totalLoadEl = document.getElementById('totalLoad');
  const capText = document.getElementById('capText');
  const momentText = document.getElementById('momentText');
  const momentCapText = document.getElementById('momentCapText');
  const leftReactionEl = document.getElementById('leftReaction');
  const rightReactionEl = document.getElementById('rightReaction');
  const status = document.getElementById('status');

  const materials = {
    steel: { capacity: 1200, moment: 2500 },
    concrete: { capacity: 900, moment: 1800 },
    wood: { capacity: 500, moment: 800 },
    custom: null
  };

  let loads = [];
  let dragId = null;

  function typeToWeight(t) {
    if (t === 'car') return 15;
    if (t === 'truck') return 80;
    if (t === 'bus') return 60;
    return Number(customWeight.value) || 0;
  }

  function applyPreset() {
    const preset = materials[bridgeType.value];
    if (!preset) return;
    capacityInput.value = preset.capacity;
    momentCapacityInput.value = preset.moment;
    render();
  }

  bridgeType.addEventListener('change', () => {
    applyPreset();
  });

  loadType.addEventListener('change', () => {
    customWeight.disabled = loadType.value !== 'custom';
  });

  addBtn.addEventListener('click', () => {
    const w = typeToWeight(loadType.value);
    const posPct = Math.max(0, Math.min(100, Number(positionInput.value)));
    const span = Math.max(1, Number(spanInput.value));
    loads.push({ w, pos: posPct / 100 * span });
    render();
  });

  resetBtn.addEventListener('click', () => {
    loads = [];
    render();
  });

  [spanInput, capacityInput, momentCapacityInput, dampingInput].forEach(el => {
    el.addEventListener('input', render);
  });

  function computeReactions(span) {
    const total = loads.reduce((s, l) => s + l.w, 0);
    const momentSum = loads.reduce((s, l) => s + l.w * l.pos, 0);
    const right = span > 0 ? momentSum / span : 0;
    const left = total - right;
    return { left, right, total };
  }

  function computeDiagrams(span, reactions) {
    const steps = 200;
    const shearPoints = [];
    const momentPoints = [];
    let maxShear = 0;
    let maxMoment = 0;
    for (let i = 0; i <= steps; i++) {
      const x = (i / steps) * span;
      let shear = reactions.left;
      loads.forEach(l => {
        if (x >= l.pos) shear -= l.w;
      });
      const moment = reactions.left * x - loads.reduce((s, l) => s + (x >= l.pos ? l.w * (x - l.pos) : 0), 0);
      maxShear = Math.max(maxShear, Math.abs(shear));
      maxMoment = Math.max(maxMoment, Math.abs(moment));
      shearPoints.push({ x, v: shear });
      momentPoints.push({ x, v: moment });
    }
    return { shearPoints, momentPoints, maxShear, maxMoment };
  }

  function drawBridge(span, reactions, diagrams) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const margin = 50;
    const yBeam = canvas.height * 0.6;
    const scaleX = (canvas.width - 2 * margin) / span;

    // Beam
    ctx.strokeStyle = '#111827';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(margin, yBeam);
    ctx.lineTo(canvas.width - margin, yBeam);
    ctx.stroke();

    // Supports
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(margin - 22, yBeam, 44, 50);
    ctx.fillRect(canvas.width - margin - 22, yBeam, 44, 50);

    // Tick marks
    ctx.strokeStyle = '#cbd5e1';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
      const x = margin + i * (canvas.width - 2 * margin) / 10;
      ctx.beginPath();
      ctx.moveTo(x, yBeam);
      ctx.lineTo(x, yBeam - 10);
      ctx.stroke();
    }

    drawLoads(span, scaleX, margin, yBeam);
    drawReactions(reactions, margin, yBeam, scaleX);
    drawDiagrams(diagrams, span, scaleX, margin);
  }

  function drawLoads(span, scaleX, margin, yBeam) {
    loads.forEach((load, idx) => {
      const x = margin + load.pos * scaleX;
      const h = Math.min(140, load.w * 1.2);
      ctx.fillStyle = '#1d4ed8';
      ctx.fillRect(x - 14, yBeam - h, 28, h);

      ctx.fillStyle = '#0f172a';
      ctx.font = '12px sans-serif';
      ctx.fillText(`${load.w} kN`, x - 18, yBeam - h - 6);
      ctx.fillText(`#${idx + 1}`, x - 10, yBeam + 16);
    });
  }

  function drawReactions(reactions, margin, yBeam, scaleX) {
    const arrow = (x, y, dir) => {
      ctx.strokeStyle = '#16a34a';
      ctx.fillStyle = '#16a34a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - dir * 50);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x - 6, y - dir * 50 + dir * 12);
      ctx.lineTo(x + 6, y - dir * 50 + dir * 12);
      ctx.lineTo(x, y - dir * 50);
      ctx.fill();
    };
    arrow(margin, yBeam + 4, 1);
    arrow(canvas.width - margin, yBeam + 4, 1);

    ctx.fillStyle = '#16a34a';
    ctx.font = '12px sans-serif';
    ctx.fillText(`${reactions.left.toFixed(1)} kN`, margin - 28, yBeam + 70);
    ctx.fillText(`${reactions.right.toFixed(1)} kN`, canvas.width - margin - 34, yBeam + 70);
  }

  function drawDiagrams(diagrams, span, scaleX, margin) {
    const shearBase = canvas.height * 0.22;
    const momentBase = canvas.height * 0.40;
    const shearScale = diagrams.maxShear > 0 ? (canvas.height * 0.14) / diagrams.maxShear : 0;
    const momentScale = diagrams.maxMoment > 0 ? (canvas.height * 0.16) / diagrams.maxMoment : 0;

    ctx.lineWidth = 2;

    // Shear diagram
    ctx.strokeStyle = '#ef4444';
    ctx.beginPath();
    diagrams.shearPoints.forEach((p, i) => {
      const x = margin + p.x * scaleX;
      const y = shearBase - p.v * shearScale;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.fillStyle = '#ef4444';
    ctx.fillText('Shear (kN)', margin + 6, shearBase - 6);

    // Moment diagram
    ctx.strokeStyle = '#8b5cf6';
    ctx.beginPath();
    diagrams.momentPoints.forEach((p, i) => {
      const x = margin + p.x * scaleX;
      const y = momentBase - p.v * momentScale;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.fillStyle = '#8b5cf6';
    ctx.fillText('Moment (kN·m)', margin + 6, momentBase - 6);

    ctx.strokeStyle = '#cbd5e1';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, shearBase);
    ctx.lineTo(canvas.width - margin, shearBase);
    ctx.moveTo(margin, momentBase);
    ctx.lineTo(canvas.width - margin, momentBase);
    ctx.stroke();
  }

  function updateStatus(total, capacity, maxMoment, momentCapacity) {
    totalLoadEl.textContent = total.toFixed(1);
    capText.textContent = capacity.toFixed(1);
    momentText.textContent = maxMoment.toFixed(1);
    momentCapText.textContent = momentCapacity.toFixed(1);
    const overload = total > capacity;
    const bendFail = maxMoment > momentCapacity;
    if (!overload && !bendFail) {
      status.textContent = 'Bridge OK';
      status.className = 'ok';
    } else {
      const reasons = [];
      if (overload) reasons.push('total load exceeds capacity');
      if (bendFail) reasons.push('bending moment exceeds capacity');
      status.textContent = 'Bridge FAILED: ' + reasons.join(' & ');
      status.className = 'fail';
    }
  }

  function renderList(span) {
    loadList.innerHTML = '';
    loads.forEach((l, i) => {
      const item = document.createElement('li');
      item.textContent = `#${i + 1}: ${l.w} kN at ${l.pos.toFixed(2)} m (${(l.pos / span * 100).toFixed(1)}%)`;
      loadList.appendChild(item);
    });
  }

  function render() {
    const span = Math.max(1, Number(spanInput.value));
    const capacity = Math.max(1, Number(capacityInput.value));
    const momentCapacity = Math.max(1, Number(momentCapacityInput.value));
    const reactions = computeReactions(span);
    const diagrams = computeDiagrams(span, reactions);
    drawBridge(span, reactions, diagrams);
    renderList(span);
    leftReactionEl.textContent = reactions.left.toFixed(1);
    rightReactionEl.textContent = reactions.right.toFixed(1);
    updateStatus(reactions.total, capacity, diagrams.maxMoment, momentCapacity);
  }

  function canvasToSpan(xCanvas, span) {
    const margin = 50;
    const scaleX = (canvas.width - 2 * margin) / span;
    const xClamped = Math.min(canvas.width - margin, Math.max(margin, xCanvas));
    return (xClamped - margin) / scaleX;
  }

  function pickLoad(xCanvas, span) {
    const margin = 50;
    const scaleX = (canvas.width - 2 * margin) / span;
    const threshold = 18;
    for (let i = loads.length - 1; i >= 0; i--) {
      const loadX = margin + loads[i].pos * scaleX;
      if (Math.abs(loadX - xCanvas) < threshold) return i;
    }
    return null;
  }

  canvas.addEventListener('pointerdown', (e) => {
    const span = Math.max(1, Number(spanInput.value));
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const id = pickLoad(x, span);
    if (id !== null) {
      dragId = id;
      canvas.classList.add('dragging');
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (dragId === null) return;
    const span = Math.max(1, Number(spanInput.value));
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    loads[dragId].pos = Math.max(0, Math.min(span, canvasToSpan(x, span)));
    render();
  });

  canvas.addEventListener('pointerup', () => {
    dragId = null;
    canvas.classList.remove('dragging');
  });
  canvas.addEventListener('pointerleave', () => {
    dragId = null;
    canvas.classList.remove('dragging');
  });

  applyPreset();
  render();
})();
</script>
</body>
</html>

